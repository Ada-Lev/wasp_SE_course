@inproceedings{solid_2024,
author = {Cabral, Raphael and Kalinowski, Marcos and Baldassarre, Maria and Villamizar, Hugo and Escovedo, Tatiana and Lopes, Hélio},
year = {2024},
month = {04},
pages = {},
title = {Investigating the Impact of SOLID Design Principles on Machine Learning Code Understanding},
doi = {10.1145/3644815.3644957}
}

@INPROCEEDINGS{datahell,
  author={Boué, Laurent and Kunireddy, Pratap and Subotić, Pavle},
  booktitle={2023 IEEE/ACM 2nd International Conference on AI Engineering – Software Engineering for AI (CAIN)}, 
  title={Automatically Resolving Data Source Dependency Hell in Large Scale Data Science Projects}, 
  year={2023},
  volume={},
  number={},
  pages={1-6},
  keywords={Codes;Pain;Soft sensors;Computational modeling;Static analysis;Production;Machine learning;data dependency;data science;static analysis},
  doi={10.1109/CAIN58948.2023.00009}}


@inproceedings{chen_tabby_2023,
	title = {Tabby: {Automated} {Gadget} {Chain} {Detection} for {Java} {Deserialization} {Vulnerabilities}},
	shorttitle = {Tabby},
	url = {https://ieeexplore.ieee.org/abstract/document/10202660},
	doi = {10.1109/DSN58367.2023.00028},
	abstract = {Java is one of the preferred options of modern developers and has become increasingly more prominent with the prevalence of the open-source culture. Thanks to the serialization and deserialization features, Java programs have the flexibility to transmit object data between multiple components or systems, which significantly facilitates development. However, the features may also allow the attackers to construct gadget chains and lead to Java deserialization vulnerabilities. Due to the highly flexible and customizable nature of Java deserialization, finding an exploitable gadget chain is complicated and usually costs researchers a great deal of effort to confirm the vulnerability. To break such a dilemma, in this paper, we introduced Tabby, a highly accurate framework that leverages the Soot framework and Neo4j graph database for finding Java deserialization gadget chains. We leveraged Tabby to analyze 248 Jar files, found 80 practical gadget chains, and received 7 CVE-IDs from Xstream and Apache Dubbo. They both improved the security design to deal with potential security risks.},
	urldate = {2023-10-03},
	booktitle = {2023 53rd {Annual} {IEEE}/{IFIP} {International} {Conference} on {Dependable} {Systems} and {Networks} ({DSN})},
	author = {Chen, Xingchen and Wang, Baizhu and Jin, Ze and Feng, Yun and Li, Xianglong and Feng, Xincheng and Liu, Qixu},
	month = jun,
	year = {2023},
	note = {ISSN: 2158-3927},
	pages = {179--192},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\brunok\\Zotero\\storage\\6MK5KJFJ\\10202660.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\brunok\\Zotero\\storage\\BZKAHZNX\\Chen et al. - 2023 - Tabby Automated Gadget Chain Detection for Java D.pdf:application/pdf},
}

@inproceedings{rasheed_hybrid_2021,
	address = {New York, NY, USA},
	series = {{ASE} '20},
	title = {A hybrid analysis to detect {Java} serialisation vulnerabilities},
	isbn = {978-1-4503-6768-4},
	url = {https://dl.acm.org/doi/10.1145/3324884.3418931},
	doi = {10.1145/3324884.3418931},
	abstract = {Serialisation related security vulnerabilities have recently been reported for numerous Java applications. Since serialisation presents both soundness and precision challenges for static analysis, it can be difficult for analyses to precisely pinpoint serialisation vulnerabilities in a Java library. In this paper, we propose a hybrid approach that extends a static analysis with fuzzing to detect serialisation vulnerabilities. The novelty of our approach is in its use of a heap abstraction to direct fuzzing for vulnerabilities in Java libraries. This guides fuzzing to produce results quickly and effectively, and it validates static analysis reports automatically. Our approach shows potential as it can detect known serialisation vulnerabilities in the Apache Commons Collections library.},
	urldate = {2023-10-10},
	booktitle = {Proceedings of the 35th {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Rasheed, Shawn and Dietrich, Jens},
	month = jan,
	year = {2021},
	keywords = {Java serialisation, program analysis, security analysis},
	pages = {1209--1213},
	file = {Full Text PDF:C\:\\Users\\brunok\\Zotero\\storage\\JE3D6HDC\\Rasheed and Dietrich - 2021 - A hybrid analysis to detect Java serialisation vul.pdf:application/pdf},
}

@inproceedings{wu_static_2022,
	address = {New York, NY, USA},
	series = {{ICCIR} '22},
	title = {A {Static} {Method} to {Discover} {Deserialization} {Gadget} {Chains} in {Java} {Programs}},
	isbn = {978-1-4503-9717-9},
	url = {https://dl.acm.org/doi/10.1145/3548608.3559310},
	doi = {10.1145/3548608.3559310},
	abstract = {Java deserialization vulnerability has become a server security problem at present. An attacker can execute arbitrary commands by submitting a malicious object for deserialization. However, existing methods for detecting Java deserialization vulnerability only find program paths to deserialize input data, it doesn't consider whether the program itself can build malicious deserialization objects, which may bring false positives. In order to solve this problem, people need to discover gadget chains in the program manually, however, it takes a lot of time. In this paper, we present a method for discovering gadget chains automatically and build a tool named Hawk Gadget in practice. The method is based on static analysis that analyzes every method in the program with control flow graph. We also Compare the Hawk Gadget with Gadget Inspector that is a tool to find gadget chains, the result shows that Hawk Gadget can find more gadget chains and has a lower false-positive rate. In addition, we use gadget chains found by Hawk Gadget in Apache-commons-collections-3 to generate malicious objects for CVE-2016-4437, and verify the effectiveness of gadget chains.},
	urldate = {2023-10-29},
	booktitle = {Proceedings of the 2022 2nd {International} {Conference} on {Control} and {Intelligent} {Robotics}},
	publisher = {Association for Computing Machinery},
	author = {Wu, Junjie and Zhao, Jingling and Fu, Junsong},
	month = oct,
	year = {2022},
	pages = {800--805},
	file = {Full Text PDF:C\:\\Users\\brunok\\Zotero\\storage\\JWU75IEW\\Wu et al. - 2022 - A Static Method to Discover Deserialization Gadget.pdf:application/pdf},
}

@inproceedings{li_improving_2023,
	title = {Improving {Precision} of {Detecting} {Deserialization} {Vulnerabilities} with {Bytecode} {Analysis}},
	url = {https://ieeexplore.ieee.org/abstract/document/10188756/references#references},
	doi = {10.1109/IWQoS57198.2023.10188756},
	abstract = {Traditional static taint analysis based on bytecode analysis such as GadgetInspector to detect deserialization vulnerabilities always faced precision problems. For example, missing the fact that taints flowing to members in called methods, type confusion, and chaotic inheritance relationships when detecting deserialization vulnerabilities, which would lead to many error results. To alleviate these problems, this paper considers three measures of improving precision of detecting deserialization vulnerabilities, including cross-function members data flow tracking, local variables and arguments types inference, and call chain subject inference based on inheritance relationships.},
	urldate = {2023-10-29},
	booktitle = {2023 {IEEE}/{ACM} 31st {International} {Symposium} on {Quality} of {Service} ({IWQoS})},
	author = {Li, Weicheng and Lu, Hui and Sun, Yanbin and Su, Shen and Qiu, Jing and Tian, Zhihong},
	month = jun,
	year = {2023},
	note = {ISSN: 2766-8568},
	pages = {1--2},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\brunok\\Zotero\\storage\\Z7AY7NQZ\\references.html:text/html;Li et al. - 2023 - Improving Precision of Detecting Deserialization V.pdf:C\:\\Users\\brunok\\Zotero\\storage\\4P5X6RA6\\Li et al. - 2023 - Improving Precision of Detecting Deserialization V.pdf:application/pdf},
}

@inproceedings{haken_automated_2018,
	title = {Automated {Discovery} of {Deserialization} {Gadget} {Chains}},
	url = {https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf},
	language = {en},
	author = {Haken, Ian},
	year = {2018},
	file = {Haken - Automated Discovery of Deserialization Gadget Chai.pdf:C\:\\Users\\brunok\\Zotero\\storage\\2LC54N5S\\Haken - Automated Discovery of Deserialization Gadget Chai.pdf:application/pdf},
}

@inproceedings{srivastava_crystallizer_2023,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2023},
	title = {Crystallizer: {A} {Hybrid} {Path} {Analysis} {Framework} to {Aid} in {Uncovering} {Deserialization} {Vulnerabilities}},
	isbn = {9798400703270},
	shorttitle = {Crystallizer},
	url = {https://dl.acm.org/doi/10.1145/3611643.3616313},
	doi = {10.1145/3611643.3616313},
	abstract = {Applications use serialization and deserialization to exchange data. Serialization allows developers to exchange messages or perform remote method invocation in distributed applications. However, the application logic itself is responsible for security. Adversaries may abuse bugs in the deserialization logic to forcibly invoke attacker-controlled methods by crafting malicious bytestreams (payloads). Crystallizer presents a novel hybrid framework to automatically uncover deserialization vulnerabilities by combining static and dynamic analyses. Our intuition is to first over-approximate possible payloads through static analysis (to constrain the search space). Then, we use dynamic analysis to instantiate concrete payloads as a proof-of-concept of a vulnerability (giving the analyst concrete examples of possible attacks). Our proof-of-concept focuses on Java deserialization as the imminent domain of such attacks. We evaluate our prototype on seven popular Java libraries against state-of-the-art frameworks for uncovering gadget chains. In contrast to existing tools, we uncovered 41 previously unknown exploitable chains. Furthermore, we show the real-world security impact of Crystallizer by using it to synthesize gadget chains to mount RCE and DoS attacks on three popular Java applications. We have responsibly disclosed all newly discovered vulnerabilities.},
	urldate = {2024-01-21},
	booktitle = {Proceedings of the 31st {ACM} {Joint} {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Srivastava, Prashast and Toffalini, Flavio and Vorobyov, Kostyantyn and Gauthier, François and Bianchi, Antonio and Payer, Mathias},
	month = nov,
	year = {2023},
	keywords = {Deserialization vulnerabiltiies, hybrid analysis, Java},
	pages = {1586--1597},
	file = {Full Text PDF:C\:\\Users\\brunok\\Zotero\\storage\\5RSHGW9Y\\Srivastava et al. - 2023 - Crystallizer A Hybrid Path Analysis Framework to .pdf:application/pdf},
}

@inproceedings{buccioli_jchainz_2023,
	address = {Berlin, Heidelberg},
	title = {{JChainz}: {Automatic} {Detection} of {Deserialization} {Vulnerabilities} for the {Java} {Language}},
	isbn = {978-3-031-29503-4},
	shorttitle = {{JChainz}},
	url = {https://doi.org/10.1007/978-3-031-29504-1_8},
	doi = {10.1007/978-3-031-29504-1_8},
	abstract = {In the last decade, we have seen the proliferation of code-reuse attacks that rely on deserialization of untrusted data in the context of web applications. The impact of these attacks is really important since they can be used for exposing private information of the users. In this paper, we design a tool for automatic discovery of deserialization vulnerabilities for the Java language. Our purpose is to devise an automatic methodology that use a set of program analysis techniques and is able to output a deserialization attack chain. We test our techniques against common Java libraries used in web technology. The execution of our tool on such a dataset was able to validate the attack chains for the majority of already known vulnerabilities, and it was also able to discover multiple novel chains that represent new types of attack vectors.},
	urldate = {2024-01-21},
	booktitle = {Security and {Trust} {Management}: 18th {International} {Workshop}, {STM} 2022, {Copenhagen}, {Denmark}, {September} 29, 2022, {Proceedings}},
	publisher = {Springer-Verlag},
	author = {Buccioli, Luca and Cristalli, Stefano and Vignati, Edoardo and Nava, Lorenzo and Badagliacca, Daniele and Bruschi, Danilo and Lu, Long and Lanzi, Andrea},
	month = apr,
	year = {2023},
	pages = {136--155},
}

@inproceedings{lai_composite_2022,
	address = {virtual},
	title = {A {Composite} {Discover} {Method} for {Gadget} {Chains} in {Java} {Deserialization} {Vulnerability}},
	abstract = {The Java deserialization vulnerability is the most dangerous and widely affected. Since this vulnerability was proposed, numerous security practitioners have studied it and developed related detection and defence tools. The discovery of the program’s potential gadget chains is the most effective defensive measure. Previously, gadget chains have relied on manual search. Automating discover gadget chains is essential for Java security. However, there are no practical tools to achieve this. So, we propose a new composite discovery method that generates the corresponding byte streams based on the static analysis results and performs deserialization detection. Our innovation combines serialization protocols and reflection mechanisms to generate objects dynamically and implement attack injection and detection. The evaluation verified its effectiveness, where we found 52 available gadget chains in Apache Commons Collections.},
	language = {en},
	author = {Lai, Zhaojia and Qu, Haipeng and Ying, Lingyun},
	month = dec,
	year = {2022},
	keywords = {Gadget Chain Detection},
	file = {Lai et al. - A Composite Discover Method for Gadget Chains in J.pdf:C\:\\Users\\brunok\\Zotero\\storage\\UPNS3UB6\\Lai et al. - A Composite Discover Method for Gadget Chains in J.pdf:application/pdf},
}

@inproceedings{chen_efficient_2024,
	title = {Efficient {Detection} of {Java} {Deserialization} {Gadget} {Chains} via {Bottom}-up {Gadget} {Search} and {Dataflow}-aided {Payload} {Construction}},
	isbn = {9798350331301},
	url = {https://www.computer.org/csdl/proceedings-article/sp/2024/313000a150/1Ub248fSq9G},
	doi = {10.1109/SP54263.2024.00150},
	abstract = {Java Object Injection (JOI) is a severe type of vulnerability affecting Java deserialization, which allows adversaries to inject a well-crafted, serialized object, thus triggering a series of chained internal methods (called gadgets) and then achieving attack consequences such as Remote Code Execution (RCE). Prior works studied the problem of detecting and chaining gadgets for JOI vulnerability using static search for possible gadget chains and dynamic construction of payload via fuzzing.  However, prior works face two following challenges: (i) path explosion in static gadget search and (ii) a lack of fine-grained object relations connected via object fields in dynamic payload construction. In this paper, we design and implement a novel Java deserialization gadget detection framework, called JDD. On one hand, JDD solves the static path explosion problem by a bottom-up approach, which first looks for gadget fragments and then chains gadget fragments from sinks to sources. The approach reduces maximum static search time from exponential to polynomial, i.e., from - to -, where - is the number of dynamic function calls in a gadget chain, - is the average number of dynamic function call candidates, and - is the number of entry points. On the other hand, JDD constructs a so-called Injection Object Construction Diagram (IOCD), which models the dataflow dependencies between injection objects’ fields to facilitate dynamic fuzzing. Our evaluation of JDD upon six real-world Java applications reveals 127 zero-day, exploitable gadget chains with six Common Vulnerabilities and Exposures (CVE) identifiers assigned. We also responsibly reported these vulnerabilities to application developers and obtained their acknowledgments and confirmations.},
	language = {English},
	urldate = {2024-02-23},
	publisher = {IEEE Computer Society},
	author = {Chen, Bofei and Zhang, Lei and Huang, Xinyou and Cao, Yinzhi and Lian, Keke and Zhang, Yuan and Yang, Min},
	month = feb,
	year = {2024},
	note = {ISSN: 2375-1207},
	pages = {150--150},
	file = {Chen et al. - Efficient Detection of Java Deserialization Gadget.pdf:C\:\\Users\\brunok\\Zotero\\storage\\WYLR3L5T\\Chen et al. - Efficient Detection of Java Deserialization Gadget.pdf:application/pdf},
}

@inproceedings{cao_improving_2023,
	address = {Melbourne, Victoria, Australia},
	series = {{ICSE} '23},
	title = {Improving {Java} {Deserialization} {Gadget} {Chain} {Mining} via {Overriding}-{Guided} {Object} {Generation}},
	isbn = {978-1-66545-701-9},
	url = {https://dl.acm.org/doi/10.1109/ICSE48619.2023.00044},
	doi = {10.1109/ICSE48619.2023.00044},
	abstract = {Java (de)serialization is prone to causing security-critical vulnerabilities that attackers can invoke existing methods (gadgets) on the application's classpath to construct a gadget chain to perform malicious behaviors. Several techniques have been proposed to statically identify suspicious gadget chains and dynamically generate injection objects for fuzzing. However, due to their incomplete support for dynamic program features (e.g., Java runtime polymorphism) and ineffective injection object generation for fuzzing, the existing techniques are still far from satisfactory. In this paper, we first performed an empirical study to investigate the characteristics of Java deserialization vulnerabilities based on our manually collected 86 publicly known gadget chains. The empirical results show that 1) Java deserialization gadgets are usually exploited by abusing runtime polymorphism, which enables attackers to reuse serializable overridden methods; and 2) attackers usually invoke exploitable overridden methods (gadgets) via dynamic binding to generate injection objects for gadget chain construction. Based on our empirical findings, we propose a novel gadget chain mining approach, GCMiner, which captures both explicit and implicit method calls to identify more gadget chains, and adopts an overriding-guided object generation approach to generate valid injection objects for fuzzing. The evaluation results show that GCMiner significantly outperforms the state-of-the-art techniques, and discovers 56 unique gadget chains that cannot be identified by the baseline approaches.},
	urldate = {2024-03-22},
	booktitle = {Proceedings of the 45th {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Cao, Sicong and Sun, Xiaobing and Wu, Xiaoxue and Bo, Lili and Li, Bin and Wu, Rongxin and Liu, Wei and He, Biao and Ouyang, Yu and Li, Jiajia},
	month = jul,
	year = {2023},
	keywords = {exploit generation, gadget chain, java deserialization vulnerability, method overriding},
	pages = {397--409},
	file = {Full Text PDF:C\:\\Users\\brunok\\Zotero\\storage\\ETJ2IHR2\\Cao et al. - 2023 - Improving Java Deserialization Gadget Chain Mining.pdf:application/pdf},
}

@inproceedings{cao_oddfuzz_2023,
	title = {{ODDFuzz}: {Discovering} {Java} {Deserialization} {Vulnerabilities} via {Structure}-{Aware} {Directed} {Greybox} {Fuzzing}},
	isbn = {978-1-66549-336-9},
	shorttitle = {{ODDFuzz}},
	url = {https://www.computer.org/csdl/proceedings-article/sp/2023/933600c726/1OXH0xA0Lrq},
	doi = {10.1109/SP46215.2023.10179377},
	abstract = {Java deserialization vulnerability is a severe threat in practice. Researchers have proposed static analysis solutions to locate candidate vulnerabilities and fuzzing solutions to generate proof-of-concept (PoC) serialized objects to trigger them. However, existing solutions have limited effectiveness and efficiency.In this paper, we propose a novel hybrid solution ODDFuzz to efficiently discover Java deserialization vulnerabilities. First, ODDFuzz performs lightweight static taint analysis to identify candidate gadget chains that may cause deserialization vulnerabilities. In this step, ODDFuzz tries to locate all candidates and avoid false negatives. Then, ODDFuzz performs directed greybox fuzzing (DGF) to explore those candidates and generate PoC testcases to mitigate false positives. Specifically, ODDFuzz applies a structure-aware seed generation method to guarantee the validity of the testcases, and adopts a novel hybrid feedback and a step-forward strategy to guide the directed fuzzing.We implemented a prototype of ODDFuzz and evaluated it on the popular Java deserialization repository ysoserial. Results show that, ODDFuzz could discover 16 out of 34 known gadget chains, while two state-of-the-art baselines only identify three of them. In addition, we evaluated ODDFuzz on real-world applications including Oracle WebLogic Server, Apache Dubbo, Sonatype Nexus, and protostuff, and found six previously unreported exploitable gadget chains with five CVEs assigned.},
	language = {English},
	urldate = {2024-03-22},
	publisher = {IEEE Computer Society},
	author = {Cao, Sicong and He, Biao and Sun, Xiaobing and Ouyang, Yu and Zhang, Chao and Wu, Xiaoxue and Su, Ting and Bo, Lili and Li, Bin and Ma, Chuanlei and Li, Jiajia and Wei, Tao},
	month = may,
	year = {2023},
	pages = {2726--2743},
	file = {Submitted Version:C\:\\Users\\brunok\\Zotero\\storage\\EIX8PKVA\\Cao et al. - 2023 - ODDFuzz Discovering Java Deserialization Vulnerab.pdf:application/pdf},
}

@inproceedings{luo_rev_2024,
	address = {Cham},
	title = {Rev {Gadget}: {A} {Java} {Deserialization} {Gadget} {Chains} {Discover} {Tool} {Based} on {Reverse} {Semantics} and {Taint} {Analysis}},
	isbn = {978-3-031-53555-0},
	shorttitle = {Rev {Gadget}},
	doi = {10.1007/978-3-031-53555-0_22},
	abstract = {Java is a widely utilized object-oriented programming language known for its powerful cross-platform features. The object serialization mechanism in Java enables the persistence and propagation of objects over the network. However, this capability also introduces deserialization vulnerabilities. Java deserialization vulnerabilities arise when an application has a deserialization entry point. Attackers can exploit this by constructing malicious serialized data, leading to the invocation of dangerous methods and resulting in issues such as command execution and information leakage. The malicious serialized data typically consists of a series of method gadget chains, commonly referred to as ’gadget chains.’To mitigate deserialization vulnerabilities, it is crucial to discover and understand the gadget chains within a program. This article introduces a tool named Rev Gadget, designed for discovering Java deserialization gadget chains. The tool employs reverse semantics and taint analysis for this purpose. The process begins with static analysis using CodeQL to identify entry and dangerous methods. Subsequently, reverse semantics are defined, and taint analysis is utilized to uncover potential deserialization gadget chains. Comparative experiments conducted using Gadget Inspector demonstrate that Rev Gadget exhibits superior detection rates, accuracy, and overall performance.},
	language = {en},
	booktitle = {Advances in {Internet}, {Data} \& {Web} {Technologies}},
	publisher = {Springer Nature Switzerland},
	author = {Luo, Yifan and Cui, Baojiang},
	editor = {Barolli, Leonard},
	year = {2024},
	pages = {229--240},
}


@inproceedings{rasthofer_machine-learning_2014,
	title = {A {Machine}-learning {Approach} for {Classifying} and {Categorizing} {Android} {Sources} and {Sinks}},
	isbn = {978-1-891562-35-8},
	doi = {10.14722/ndss.2014.23039},
	author = {Rasthofer, Siegfried and Arzt, Steven and Bodden, Eric},
	month = jan,
	year = {2014},
	file = {Submitted Version:C\:\\Users\\brunok\\Zotero\\storage\\QF5HBQTJ\\Rasthofer et al. - 2014 - A Machine-learning Approach for Classifying and Ca.pdf:application/pdf},
}


@article{wang_systematic_2020,
	title = {A systematic review of fuzzing based on machine learning techniques},
	volume = {15},
	url = {https://doi.org/10.1371/journal.pone.0237749},
	doi = {10.1371/journal.pone.0237749},
	abstract = {Security vulnerabilities play a vital role in network security system. Fuzzing technology is widely used as a vulnerability discovery technology to reduce damage in advance. However, traditional fuzz testing faces many challenges, such as how to mutate input seed files, how to increase code coverage, and how to bypass the format verification effectively. Therefore machine learning techniques have been introduced as a new method into fuzz testing to alleviate these challenges. This paper reviews the research progress of using machine learning techniques for fuzz testing in recent years, analyzes how machine learning improves the fuzzing process and results, and sheds light on future work in fuzzing. Firstly, this paper discusses the reasons why machine learning techniques can be used for fuzzing scenarios and identifies five different stages in which machine learning has been used. Then this paper systematically studies machine learning-based fuzzing models from five dimensions of selection of machine learning algorithms, pre-processing methods, datasets, evaluation metrics, and hyperparameters setting. Secondly, this paper assesses the performance of the machine learning techniques in existing research for fuzz testing. The results of the evaluation prove that machine learning techniques have an acceptable capability of prediction for fuzzing. Finally, the capability of discovering vulnerabilities both traditional fuzzers and machine learning-based fuzzers is analyzed. The results depict that the introduction of machine learning techniques can improve the performance of fuzzing. We hope to provide researchers with a systematic and more in-depth understanding of fuzzing based on machine learning techniques and provide some references for this field through analysis and summarization of multiple dimensions.},
	number = {8},
	journal = {PLOS ONE},
	author = {Wang, Yan and Jia, Peng and Liu, Luping and Huang, Cheng and Liu, Zhonglin},
	month = aug,
	year = {2020},
	note = {Publisher: Public Library of Science},
	pages = {1--37},
}

@inproceedings{fuzzslice,
author = {Murali, Aniruddhan and Mathews, Noble and Alfadel, Mahmoud and Nagappan, Meiyappan and Xu, Meng},
title = {FuzzSlice: Pruning False Positives in Static Analysis Warnings through Function-Level Fuzzing},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3623321},
doi = {10.1145/3597503.3623321},
abstract = {Manual confirmation of static analysis reports is a daunting task. This is due to both the large number of warnings and the high density of false positives among them. Fuzzing techniques have been proposed to verify static analysis warnings. However, a major limitation is that fuzzing the whole project to reach all static analysis warnings is not feasible. This can take several days and exponential machine time to increase code coverage linearly.Therefore, we propose FuzzSlice, a novel framework that automatically prunes possible false positives among static analysis warnings. Unlike prior work that mostly focuses on confirming true positives among static analysis warnings, which inevitably requires end-to-end fuzzing, FuzzSlice focuses on ruling out potential false positives, which are the majority in static analysis reports. The key insight that we base our work on is that a warning that does not yield a crash when fuzzed at the function level in a given time budget is a possible false positive. To achieve this, FuzzSlice first aims to generate compilable code slices at the function level. Then, FuzzSlice fuzzes these code slices instead of the entire binary to prune possible false positives. FuzzSlice is also unlikely to misclassify a true bug as a false positive because the crashing input can be reproduced by a fuzzer at the function level as well. We evaluate FuzzSlice on the Juliet synthetic dataset and real-world complex C projects: openssl, tmux and openssh-portable. Our evaluation shows that the ground truth in the Juliet dataset had 864 false positives which were all detected by FuzzSlice. For the open-source repositories, we were able to get the developers from two of these open-source repositories to independently label these warnings. FuzzSlice automatically identifies 33 out of 53 false positives confirmed by developers in these two repositories. This implies that FuzzSlice can reduce the number of false positives by 62.26\% in the open-source repositories and by 100\% in the Juliet dataset.},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {65},
numpages = {13},
keywords = {fuzzing, static analysis warning, vulnerability},
series = {ICSE '24}
}

@misc{codeintelligencetesting-no-date,
	author = {CodeIntelligenceTesting},
	title = {{GitHub - CodeIntelligenceTesting/jazzer: Coverage-guided, in-process fuzzing for the JVM}},
	url = {https://github.com/CodeIntelligenceTesting/jazzer},
}

@inproceedings{hidden_debt,
author = {Sculley, D. and Holt, Gary and Golovin, Daniel and Davydov, Eugene and Phillips, Todd and Ebner, Dietmar and Chaudhary, Vinay and Young, Michael and Crespo, Jean-Francois and Dennison, Dan},
title = {Hidden technical debt in Machine learning systems},
year = {2015},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
abstract = {Machine learning offers a fantastically powerful toolkit for building useful complex prediction systems quickly. This paper argues it is dangerous to think of these quick wins as coming for free. Using the software engineering framework of technical debt, we find it is common to incur massive ongoing maintenance costs in real-world ML systems. We explore several ML-specific risk factors to account for in system design. These include boundary erosion, entanglement, hidden feedback loops, undeclared consumers, data dependencies, configuration issues, changes in the external world, and a variety of system-level anti-patterns.},
booktitle = {Proceedings of the 28th International Conference on Neural Information Processing Systems - Volume 2},
pages = {2503–2511},
numpages = {9},
location = {Montreal, Canada},
series = {NIPS'15}
}

@misc{kreysig_analyzing_2024,
	title = {Analyzing {Prerequisites} of known {Deserialization} {Vulnerabilities} on {Java} {Applications}},
	url = {https://www.abartel.net/static/p/ease2024-javaDeser.pdf},
	language = {en},
	author = {Kreyßig, Bruno and Bartel, Alexandre},
	year = {2024},
}

@inproceedings{fuzzing2020,
author = {Böhme, Marcel and Falk, Brandon},
year = {2020},
month = {11},
pages = {713-724},
title = {Fuzzing: on the exponential cost of vulnerability discovery},
doi = {10.1145/3368089.3409729}
}